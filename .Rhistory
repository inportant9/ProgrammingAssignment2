VAR_0382, VAR_0385, VAR_0386, VAR_0387, VAR_0388, VAR_0389, VAR_0390, VAR_0391, VAR_0393,
VAR_0396, VAR_0397, VAR_0398, VAR_0399, VAR_0400, VAR_0401, VAR_0402, VAR_0403, VAR_0405,
VAR_0406, VAR_0407, VAR_0408, VAR_0409, VAR_0410, VAR_0412, VAR_0413, VAR_0414, VAR_0415,
VAR_0416, VAR_0417, VAR_0418, VAR_0419, VAR_0420, VAR_0421, VAR_0422, VAR_0423, VAR_0424,
VAR_0425, VAR_0426, VAR_0427, VAR_0428, VAR_0429, VAR_0430, VAR_0431, VAR_0432, VAR_0433,
VAR_0434, VAR_0435, VAR_0436, VAR_0437, VAR_0439, VAR_0440, VAR_0441, VAR_0442, VAR_0443,
VAR_0444, VAR_0445, VAR_0447, VAR_0448, VAR_0449, VAR_0450, VAR_0451, VAR_0452, VAR_0453,
VAR_0454, VAR_0455, VAR_0456, VAR_0457, VAR_0458, VAR_0460, VAR_0461, VAR_0462, VAR_0463,
VAR_0464, VAR_0465, VAR_0469, VAR_0470, VAR_0471, VAR_0472, VAR_0473, VAR_0474, VAR_0475,
VAR_0476, VAR_0477, VAR_0478, VAR_0479, VAR_0480, VAR_0481, VAR_0482, VAR_0483, VAR_0484,
VAR_0485, VAR_0486, VAR_0487, VAR_0488, VAR_0489, VAR_0491, VAR_0492, VAR_0494, VAR_0495,
VAR_0496, VAR_0497, VAR_0498, VAR_0499, VAR_0500, VAR_0501, VAR_0506, VAR_0507, VAR_0508,
VAR_0509, VAR_0510, VAR_0511, VAR_0512, VAR_0513, VAR_0514, VAR_0515, VAR_0516, VAR_0517,
VAR_0518, VAR_0519, VAR_0520, VAR_0521, VAR_0522, VAR_0523, VAR_0524, VAR_0525, VAR_0531,
VAR_0532, VAR_0533, VAR_0534, VAR_0535, VAR_0536, VAR_0537, VAR_0538, VAR_0539, VAR_0540,
VAR_0541, VAR_0542, VAR_0543, VAR_0544, VAR_0545, VAR_0546, VAR_0547, VAR_0548, VAR_0549,
VAR_0550, VAR_0551, VAR_0552, VAR_0553, VAR_0554, VAR_0555, VAR_0556, VAR_0557, VAR_0558,
VAR_0559, VAR_0560, VAR_0561, VAR_0562, VAR_0564, VAR_0565, VAR_0568, VAR_0569, VAR_0570,
VAR_0571, VAR_0572, VAR_0573, VAR_0574, VAR_0575, VAR_0576, VAR_0577, VAR_0578, VAR_0579,
VAR_0580, VAR_0581, VAR_0582, VAR_0583, VAR_0584, VAR_0585, VAR_0586, VAR_0587, VAR_0588,
VAR_0589, VAR_0590, VAR_0591, VAR_0592, VAR_0593, VAR_0594, VAR_0595, VAR_0596, VAR_0597,
VAR_0598, VAR_0599, VAR_0600, VAR_0601, VAR_0602, VAR_0603, VAR_0604, VAR_0605, VAR_0606,
VAR_0607, VAR_0608, VAR_0609, VAR_0610, VAR_0611, VAR_0612, VAR_0613, VAR_0614, VAR_0615,
VAR_0616, VAR_0617, VAR_0618, VAR_0619, VAR_0620, VAR_0621, VAR_0622, VAR_0623, VAR_0624,
VAR_0625, VAR_0626, VAR_0627, VAR_0628, VAR_0629, VAR_0630, VAR_0631, VAR_0632, VAR_0633,
VAR_0634, VAR_0635, VAR_0636, VAR_0637, VAR_0638, VAR_0639, VAR_0640, VAR_0641, VAR_0642,
VAR_0643, VAR_0644, VAR_0645, VAR_0646, VAR_0647, VAR_0648, VAR_0649, VAR_0650, VAR_0651,
VAR_0652, VAR_0653, VAR_0654, VAR_0655, VAR_0656, VAR_0657, VAR_0658, VAR_0659, VAR_0660,
VAR_0661, VAR_0662, VAR_0663, VAR_0664, VAR_0665, VAR_0666, VAR_0667, VAR_0668, VAR_0669,
VAR_0670, VAR_0671, VAR_0672, VAR_0673, VAR_0674, VAR_0675, VAR_0676, VAR_0677, VAR_0678,
VAR_0679, VAR_0680, VAR_0681, VAR_0682, VAR_0683, VAR_0684, VAR_0685, VAR_0686, VAR_0687,
VAR_0688, VAR_0689, VAR_0690, VAR_0691, VAR_0692, VAR_0693, VAR_0694, VAR_0695, VAR_0696,
VAR_0697, VAR_0698, VAR_0699, VAR_0700, VAR_0701, VAR_0702, VAR_0703, VAR_0704, VAR_0705,
VAR_0706, VAR_0707, VAR_0708, VAR_0709, VAR_0710, VAR_0711, VAR_0712, VAR_0713, VAR_0714,
VAR_0715, VAR_0716, VAR_0717, VAR_0718, VAR_0719, VAR_0720, VAR_0721, VAR_0722, VAR_0723,
VAR_0724, VAR_0725, VAR_0726, VAR_0727, VAR_0728, VAR_0729, VAR_0730, VAR_0731, VAR_0734,
VAR_0735, VAR_0738, VAR_0742, VAR_0743, VAR_0744, VAR_0745, VAR_0746, VAR_0747, VAR_0748,
VAR_0749, VAR_0750, VAR_0751, VAR_0752, VAR_0753, VAR_0754, VAR_0755, VAR_0756, VAR_0757,
VAR_0758, VAR_0759, VAR_0760, VAR_0761, VAR_0762, VAR_0763, VAR_0764, VAR_0765, VAR_0766,
VAR_0767, VAR_0768, VAR_0769, VAR_0770, VAR_0771, VAR_0772, VAR_0773, VAR_0774, VAR_0775,
VAR_0776, VAR_0777, VAR_0778, VAR_0779, VAR_0780, VAR_0781, VAR_0782, VAR_0783, VAR_0784,
VAR_0785, VAR_0786, VAR_0787, VAR_0788, VAR_0789, VAR_0790, VAR_0791, VAR_0792, VAR_0793,
VAR_0794, VAR_0795, VAR_0796, VAR_0797, VAR_0798, VAR_0799, VAR_0800, VAR_0801, VAR_0802,
VAR_0803, VAR_0804, VAR_0805, VAR_0806, VAR_0807, VAR_0808, VAR_0809, VAR_0810, VAR_0811,
VAR_0812, VAR_0813, VAR_0814, VAR_0815, VAR_0816, VAR_0817, VAR_0818, VAR_0819, VAR_0820,
VAR_0821, VAR_0822, VAR_0823, VAR_0824, VAR_0825, VAR_0826, VAR_0827, VAR_0828, VAR_0829,
VAR_0830, VAR_0831, VAR_0832, VAR_0833, VAR_0834, VAR_0835, VAR_0836, VAR_0837, VAR_0838,
VAR_0839, VAR_0841, VAR_0842, VAR_0843, VAR_0844, VAR_0845, VAR_0846, VAR_0848, VAR_0849,
VAR_0850, VAR_0851, VAR_0852, VAR_0853, VAR_0854, VAR_0855, VAR_0856, VAR_0857, VAR_0858,
VAR_0859, VAR_0860, VAR_0861, VAR_0862, VAR_0863, VAR_0864, VAR_0865, VAR_0866, VAR_0867,
VAR_0868, VAR_0869, VAR_0870, VAR_0871, VAR_0872, VAR_0873, VAR_0874, VAR_0875, VAR_0876,
VAR_0877, VAR_0878, VAR_0879, VAR_0880, VAR_0881, VAR_0882, VAR_0883, VAR_0884, VAR_0885,
VAR_0886, VAR_0887, VAR_0888, VAR_0889, VAR_0890, VAR_0891, VAR_0892, VAR_0893, VAR_0894,
VAR_0895, VAR_0896, VAR_0897, VAR_0898, VAR_0899, VAR_0900, VAR_0901, VAR_0902, VAR_0903,
VAR_0904, VAR_0905, VAR_0906, VAR_0907)
olsreg <- lm(y ~ x, data=feature_cts )
summary(olsreg)
for (i in 1:3){
quant0_fcts <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
print(quant0_fcts)
for (i in 1:2){
quant0_fcts <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
print(quant0_fcts)
for (i in 1:3){
quant0_fcts(1,i) <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts(1:i) <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
for (i in 1:3){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts[i] <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
quant0_fcts <- list[i]
quant1_fcts <- list[i]
for (i in 1:3){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts[i] <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
quant0_fcts <- list[1881]
quant1_fcts <- list[1881]
for (i in 1:3){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts[i] <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
source('~/Desktop/Springleaf/springleaf.0904.R')
source('~/Desktop/Springleaf/springleaf.0904.R')
quant0_fcts$newcolumn <- 0
quant1_fcts$newcolumn <- 0
for (i in 1:nrow(feature_fcts)) {
n <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant0_fcts$newcolumn <- n
}
quant0_fcts$newcolumn <- 0
quant1_fcts$newcolumn <- 0
for (i in 1:nrow(feature_cts)) {
n <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant0_fcts$newcolumn <- n
}
warning()
warnings()
quant0_fcts
for (i in 1:3){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)
quant1_fcts[i] <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
for (i in 1:3){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)}
for (i in 1:1){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)}
quant1_fcts[i] <- quantile(feature_cts[target == 1, i], na.rm = TRUE)
}
for (i in 1:1){
quant0_fcts[i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)}
for(k in 1:length(colnames(feature_cts))) {  #each column set as numeric
quant0_fcts<-columnQuantile(feature_cts) #take the sum of the rows
return(quant0_fcts)
}
}
for(k in 1:length(colnames(feature_cts))) {  #each column set as numeric
quant0_fcts<-columnQuantile(feature_cts) #take the sum of the rows
return(quant0_fcts)
}
for (i in 1:10){
quantile(quant0_fcts[,i],feature_cts[target == 0, i], na.rm = TRUE)}
for (i in 1:10){
quantile(feature_cts[,i],feature_cts[target == 0, i], na.rm = TRUE)}
for (i in 1:10){
quantile(feature_cts[,i],feature_cts[target == 0, i], na.rm = TRUE)}
View(feature_factor)
quant0_fcts = matrix(rnorm(145231*1797),145231,1797)
for (i in 1:1797){
quantile(feature_cts[,i],feature_cts[target == 0, i], na.rm = TRUE)}
for (i in 1:1797){
quant0_fcts <- quantile(feature_cts[target == 0, i], na.rm = TRUE)}
quant0_fcts
for (i in 1:1797){
quant0_fcts[,i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)}
for (i in 1:1797){
quant0_fcts[1,i] <- quantile(feature_cts[target == 0, i], na.rm = TRUE)}
quant0_fcts <- matrix(0, nrow = ncol(feature_cts), ncol = 5)
quant1_fcts <- matrix(0, nrow = ncol(feature_cts), ncol = 5)
for (ind in 1:ncol(feature_cts)) {
quant0_fcts[ind, ] <- quantile(feature_cts[target == 0, ind], na.rm = TRUE)
quant1_fcts[ind, ] <- quantile(feature_cts[target == 1, ind], na.rm = TRUE)
}
quant_fcts_dif = quant0_fcts - quant1_fcts
View(quant_fcts_dif)
View(quant_fcts_dif)
quant0_fcts
View(quant0_fcts)
View(quant0_fcts)
View(quant1_fcts)
View(quant1_fcts)
install.packages("randomForest")
# load the raw data from csv file
train = read.csv("~Desktop/springleaf/train.csv", row.names = 1, stringsAsFactors = FALSE)
y = train$target
# remove the target
train = subset(train, select = -target)
# get the rowcount
cat("Row count : ", nrow(train), "; Predictor column count : ", ncol(train))
# the proportion of NA values.
length(train[is.na(train)]) / (ncol(train) * nrow(train))
# check for dupicate rows.
nrow(train) - nrow(unique(train))
# identify and separate the numeric and non numeric rows.
train_numr = train[, sapply(train, is.numeric)]
train_char = train[, sapply(train, is.character)]
cat("Numerical column count : ", dim(train_numr)[2],
"; Character column count : ", dim(train_char)[2])
# dig into the character features.
str(lapply(train_char, unique), vec.len = 4)
# convert missing values to NA.
train_char[train_char == -1] = NA
train_char[train_char == ""] = NA
train_char[train_char == "[]"] = NA
# look at the columns with only one unique value.
col_ct_char = sapply(train_char, function(x) length(unique(x[!is.na(x)])))
cat("Constant character feature count:", length(col_ct_char[col_ct_char <= 1]))
# remove these columns
train_char = train_char[, !names(train_char) %in% names(col_ct_char[col_ct_char <= 1])]
# place the date columns in a new dataframe and parse the dates
train_date = train_char[, grep("JAN1|FEB1|MAR1", train_char)]
# separate out the dates from the character columns and look at them further.
train_char = train_char[, !colnames(train_char) %in% colnames(train_date)]
train_date = sapply(train_date, function(x) strptime(x, "%d%B%y:%H:%M:%S"))
train_date = do.call(cbind.data.frame, train_date)
# take out the times to a different data frame.
train_time = train_date[, colnames(train_date) %in% c("VAR_0204","VAR_0217")]
train_time = data.frame(sapply(train_time, function(x) strftime(x, "%H:%M:%S")))
train_hour = as.data.frame(sapply(train_time, function(x) as.numeric(as.character(substr( x ,1, 2)))))
# convert character to factors
train_char = data.frame(lapply(train_char, factor))
# plot histogram of dates.
par(mar = c(2, 2, 2, 2), mfrow = c(4, 4))
for (i in 1:16) {
hist(train_date[, i], "weeks", format = "%d %b %y",
main = colnames(train_date)[i], xlab = "", ylab = "")
}
# plot histogram of times.
par(mar = c(2, 2, 2, 2), mfrow = c(1, 2))
for (i in 1:2) {
hist(train_hour[, i], main = paste(colnames(train_hour)[i], "hourly"),
breaks = c(0:24), xlab = "", ylab = "")
}
# the numerical values.
# look at the columns with only one unique value.
col_ct_numr = sapply(train_numr, function(v) var(v, na.rm = TRUE) == 0)
cat("Constant numeric feature count:", sum(col_ct_numr == TRUE))
# remove these columns
train_numr = train_numr[, !col_ct_numr]
################################################################################
# Data clean finish.
#
# train_numr for numeric features;
# train_char for categorical features;
# y for response;
# train_numr and train_char contain NA for missing values.
# model fitting (random forest)
library(randomForest)
train_complete = na.roughfix(cbind(train_char[, -c(3, 9, 10, 14, 18, 20)], train_numr))
# index of random samples for training
index_train = sample(145231, 10000)
# random sampled training data with imputed missing values
sample_train_complete = train_complete[index_train, ]
sample_y = y[index_train]
fit = randomForest(sample_train_complete, as.factor(sample_y))
source('~/Desktop/Springleaf/springleaf0922.R')
# load the raw data from csv file
train = read.csv("~/Desktop/springleaf/train.csv", row.names = 1, stringsAsFactors = FALSE)
y = train$target
train = subset(train, select = -target)
# get the rowcount
cat("Row count : ", nrow(train), "; Predictor column count : ", ncol(train))
# the proportion of NA values.
length(train[is.na(train)]) / (ncol(train) * nrow(train))
# check for dupicate rows.
nrow(train) - nrow(unique(train))
# identify and separate the numeric and non numeric rows.
train_numr = train[, sapply(train, is.numeric)]
train_char = train[, sapply(train, is.character)]
cat("Numerical column count : ", dim(train_numr)[2],
"; Character column count : ", dim(train_char)[2])
# dig into the character features.
str(lapply(train_char, unique), vec.len = 4)
# convert missing values to NA.
train_char[train_char == -1] = NA
train_char[train_char == ""] = NA
train_char[train_char == "[]"] = NA
# look at the columns with only one unique value.
col_ct_char = sapply(train_char, function(x) length(unique(x[!is.na(x)])))
cat("Constant character feature count:", length(col_ct_char[col_ct_char <= 1]))
# remove these columns
train_char = train_char[, !names(train_char) %in% names(col_ct_char[col_ct_char <= 1])]
# place the date columns in a new dataframe and parse the dates
train_date = train_char[, grep("JAN1|FEB1|MAR1", train_char)]
# separate out the dates from the character columns and look at them further.
train_char = train_char[, !colnames(train_char) %in% colnames(train_date)]
train_date = sapply(train_date, function(x) strptime(x, "%d%B%y:%H:%M:%S"))
train_date = do.call(cbind.data.frame, train_date)
# take out the times to a different data frame.
train_time = train_date[, colnames(train_date) %in% c("VAR_0204","VAR_0217")]
train_time = data.frame(sapply(train_time, function(x) strftime(x, "%H:%M:%S")))
train_hour = as.data.frame(sapply(train_time, function(x) as.numeric(as.character(substr( x ,1, 2)))))
# convert character to factors
train_char = data.frame(lapply(train_char, factor))
# plot histogram of dates.
par(mar = c(2, 2, 2, 2), mfrow = c(4, 4))
for (i in 1:16) {
hist(train_date[, i], "weeks", format = "%d %b %y",
main = colnames(train_date)[i], xlab = "", ylab = "")
}
# plot histogram of times.
par(mar = c(2, 2, 2, 2), mfrow = c(1, 2))
for (i in 1:2) {
hist(train_hour[, i], main = paste(colnames(train_hour)[i], "hourly"),
breaks = c(0:24), xlab = "", ylab = "")
}
# the numerical values.
# look at the columns with only one unique value.
col_ct_numr = sapply(train_numr, function(v) var(v, na.rm = TRUE) == 0)
cat("Constant numeric feature count:", sum(col_ct_numr == TRUE))
# remove these columns
train_numr = train_numr[, !col_ct_numr]
################################################################################
# Data clean finish.
#
# train_numr for numeric features;
# train_char for categorical features;
# y for response;
# train_numr and train_char contain NA for missing values.
# model fitting (random forest)
library(randomForest)
train_complete = na.roughfix(cbind(train_char[, -c(3, 9, 10, 14, 18, 20)], train_numr))
# index of random samples for training
index_train = sample(145231, 10000)
# random sampled training data with imputed missing values
sample_train_complete = train_complete[index_train, ]
sample_y = y[index_train]
fit = randomForest(sample_train_complete, as.factor(sample_y))
index_train = sample(145231, 145231)
# random sampled training data with imputed missing values
sample_train_complete = train_complete[index_train, ]
sample_y = y[index_train]
fit = randomForest(sample_train_complete, as.factor(sample_y))
source('~/Desktop/Springleaf/springleaf0922.R')
hw1_data <- read.csv("~/Desktop/Cousera/R Programming Jan 05/W1 Quiz/hw1_data.csv")
View(hw1_data)
View(hw1_data)
x <- 4L
class(x)
x <- c(4, "a", TRUE)
class(x)
x <- c(1,3, 5)
y <- c(3, 2, 10)
cbind(x,y)
x <- list(2, "a", "b", TRUE)
class(x[[1]])
x <- c(3, 5, 1, 10, 12, 6)
x[x %in% 1:5] <- 0
x
hw1_data <- read.csv("~/Desktop/Cousera/R Programming Jan 05/W1 Quiz/hw1_data.csv")
View(hw1_data)
help
sum(is.na(ozone))
sum(is.na($ozone))
sum(is.na(hw1_data$ozone))
sum(is.nan(hw1_data$ozone))
sum(is.na(hw1_data$Ozone))
mean(hw1_data@Ozone)
mean(hw1_data$Ozone)
library(plyr)
# Run the functions length, mean, and sd on the value of "change" for each group,
# broken down by sex + condition
cdata <- ddply(hw1_data, c("Ozone"), summarise,
N    = length(change),
mean = mean(change),
sd   = sd(change),
se   = sd / sqrt(N)
)
library(plyr)
help(na.rm)
??na.rm
data <- hw1_data
apply(data[,2:ncol(data)], 2, function(x) mean(x, na.rm=TRUE))
apply(data[,1:ncol(data)], 2, function(x) mean(x, na.rm=TRUE))
mean(data$Solar.R| data$Ozone>31| data$Temp>90)
mean(data$Solar.R| data$Ozone>31| data$Temp>90)
mean(data$Solar.R| data$Ozone>31)
mean(data$Solar.R| data$Ozone>31)
mean(data[data$Ozone>0,"Solar.R"])
install.packages("swirl")
library(swirl)
swirl()
library(swirl)
swirl()
swirl()
install_from_swirl("R Programming")
swirl()
5+7
x <- 5+7
x
x-3
y<-x - 3
y
z<-c(1.1,9,3.14)
?c
z
c(z,555)
c(z,555,z)
z*2+100
my_sqrt<-sqrt(z-1)
my_sqrt
my_div <-z/my_sqrt
my_div
c(1,2,3,4)+c(0,10)
c(1,2,3,4)+c(0,10,100)
z*2+100
z*2+1000
my
my_div
getwd()
ls()
x<-9
ls()
list.files()
?list.files
args()
args(list.files())
args(list.files
)
old.dir<-getwd()
testdir<-dir.create()
dir.create(testdir)
testdir<-dir.create()
dir.create()
dir.create(getwd(testdir))
dir.create("/Users/apple/testdir")
dir.create("testdir")
setwd("testdir")
file.create("mytest.R")
getwd()
list.files()
file.exists()
file.exists()
file.exists("mytest.R")
file.info("mytest.R")
file.rename("mytest2.R")
file.rename("mytest.R"to"mytest2.R")
file.rename("mytest.R" to "mytest2.R")
file.rename("mytest.R") to "mytest2.R"
?file.rename()
file.rename("mytest.R","mytest2.R")
file.copy("mytest2.R","mytes3,R")
file.copy("mytest2.R","mytest3,R")
file.copy("mytest2.R", "mytest3,R")
file.copy("mytest2.R", "mytest3.R")
file.path("mytest3.R")
file.path('folder1','folder2')
?dir.create
dir.create("testdir3")
dir.create(file.path('testdir2,"testdir3")
)
)
)))
dir.create(file.path('testdir2','testdir3')
)
dir.create(file.path('testdir2','testdir3',recursive = true)
dir.create(file.path('testdir2','testdir3'),recursive = true)
dir.create(file.path('testdir2','testdir3'),recursive = TRUE)
delete("testdir2")
unlink("testdir2")
unlink("testdir2", recursive = TRUE)
setwd()
setwd('old.dir')
'old.dir'<-setwd()
old.dir<-setwd()
setwd(old.dir)
delete testdir
unlink("testdir", recursive = TRUE)
swirl()
library(swirl)
swirl()
swirl()
==
'=='
TRUE == TRUE
(FALSE==TRUE)==FALSE
6==7
6<7
10<=10
5!=7
5=7
5!=7
5==7
!5==7
FALSE & FALSE
TRUE& C(TRUE,FALSE,FALSE)
TRUE & C(TRUE,FALSE,FALSE)
TRUE & C(TRUE, FALSE, FALSE)
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE OR c(TRUE,FALSE,FALSE)
TRUE c(TRUE,FALSE,FALSE)
TRUE | c(TRUE,FALSE,FALSE)
TRUE || c(TRUE,FALSE,FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTRUE(6>4)
identical('twins','twins')
xor(5 == 6,!FALSE)
ints <- sample(10)
ints
ints > 5
which(ints>7)
any(ints<0)
all(ints>0)
install.packages("swirl")
install.packages("swirl")
swril()
swirl()
library("swirl")
swirl()
head(flags)
DIM(FLAGS)
dim(flags)
class(flags)
cls_list <- lappy(flags,class)
cls_list <- lapply(flags,class)
cls_list
class(cls_list)
as.character(cls_list)
sapply(cls_list)
sapply(cls_list,flags)
cls_vect<-sapply(cls_list,flag)
cls_vect<-sapply(flags,class)
class)cls_vect
class(cls_vect)
install.packages("swirl")
install.packages("swirl")
install.packages("swirl")
packageVersion("swirl")
install_from_swirl("R Programming")
install_from_swirl("R Programming")
install_from_swirl("R Programming")
install.packages(c("A3", "abc", "ABCp2", "abctools", "abd", "abf2", "abind", "accelerometry", "AcceptanceSampling", "accrual", "accrued", "ACNE", "acp", "Actigraphy", "actuar", "adabag", "adagio", "AdapEnetClass", "AdaptFitOS", "ade4", "ade4TkGUI", "adegenet", "adehabitat", "adehabitatHR", "adehabitatHS", "adehabitatLT", "adehabitatMA", "adwave", "AER", "afex", "AFLPsim", "AGD", "agRee", "agricolae", "agrmt", "AGSDest", "AICcmodavg", "AID", "akima", "alabama", "aLFQ", "allanvar", "alleHap", "alm", "alphahull", "alphashape3d", "ALS", "Amelia", "AmpliconDuo", "anacor", "analogue", "animation", "Anthropometry", "antitrust", "apc", "ape", "aprof", "apsimr", "apt", "archdata", "archivist", "arfima", "argparser", "arm", "aroma.apd", "aroma.cn", "ARPobservation", "aRpsDCA", "arules", "arulesNBMiner", "arulesSequences", "arulesViz", "aRxiv", "asbio", "ash", "ASMap", "aspect", "assertive", "aster", "aster2", "astrochron", "asypow", "autoencoder", "autopls", "AutoSEARCH", "awsMethods", "BaBooN", "babynames", "backtest", "BalancedSampling", "bamdit", "BAMMtools", "bartMachine", "BAS", "base64enc", "baseline", "BaSTA", "BAT", "BatchExperiments", "BatchJobs", "BayesBridge", "BayesComm", "bayescount", "BayesFactor", "bayesGARCH", "BayesLCA", "bayesLife", "bayesm", "bayesmix", "bayesPop", "bayesSurv", "bayesTFR", "bayou", "BBmisc", "bbmle", "bc3net", "BCBCSF", "BcDiag", "BCEA", "BCEs0", "Bchron", "bcp", "bcrm", "bcv", "bda", "BDgraph", "beepr", "beeswarm", "Benchmarking", "benford.analysis", "BenfordTests", "bentcableAR", "berryFunctions", "BEST", "bfp", "BH", "BHH2", "BiasedUrn", "biclust", "BIFIEsurvey", "biganalytics", "bigmemory", "bigml", "bigpca", "bigsplines", "bigtabulate", "bild", "binda", "bingat", "binr", "binseqtest", "Biodem", "BiodiversityR", "BioMark", "biotools", "biplotbootGUI", "birk", "bisoreg", "bit64", "biwavelet", "bizdays", "BlakerCI", "BlandAltmanLeh", "Blaunet", "blme", "blockcluster", "blocksdesign", "BMA", "BMhyd", "Bmix", "BMS", "bnlearn", "BNPdensity", "boa", "boilerpipeR", "BOIN", "bold", "BoolNet", "boot", "bootES", "bootLR", "bootstrap", "bootSVD", "Boruta", "bpcp", "bqtl", "BradleyTerry2", "BrailleR", "breakaway", "breakpoint", "broman", "BSGW", "bspec", "BSSasymp", "bst", "bsts", "bujar", "bvarsv", "bvpSolve", "C50", "ca", "cacIRT", "CaDENCE", "Cairo", "calmate", "CAMAN", "cancerTiming", "candisc", "capushe", "car", "CARBayes", "CARBayesST", "carcass", "cardidates", "care", "caret", "CarletonStats", "caseMatch", "CatDyn", "catenary", "cati", "catnet", "catR", "causaleffect", "causalsens", "CAvariants", "cba", "CBPS", "CCAGFA", "cccd", "cccrm", "cclust", "CCMnet", "CDM", "CDNmoney", "CDVine", "CEC", "cec2005benchmark", "cec2013", "celestial", "cem", "cepp", "cgam", "cgdsr", "cghseg", "cgwtools", "ChainLadder", "changepoint", "chebpol", "checkmate", "checkpoint", "cheddar", "chemCal", "ChemometricsWithR", "cherry", "chillR", "chipPCR", "chngpt", "CHNOSZ", "choroplethr", "chron", "CHsharp", "CIDnetworks", "circlize", "Ckmeans.1d.dp", "class", "classGraph", "classInt", "clere", "clhs", "ClickClust", "clickstream", "climdex.pcic", "clinfun", "clinsig", "clue", "clues", "cluster", "clusterGeneration", "clusterSim", "clustMD", "ClustVarLV", "cmrutils", "cmvnorm", "cna", "cncaGUI", "CNVassoc", "coalescentMCMC", "coarseDataTools", "cobs", "cocor", "cocorresp", "cocron", "coda", "codep", "codetools", "coefficientalpha", "coefplot", "coenocliner", "coin", "cold", "CollocInfer", "colorscience", "colorspace", "colourlovers", "CombinS", "Comp2ROC", "compare", "compareGroups", "CompareTests", "Compind", "complmrob", "COMPoissonReg", "compound.Cox", "CompRandFld", "ConConPiWiFun", "coneproj", "confreq", "conicfit", "conting", "cooccur", "copBasic", "copCAR", "copula", "corclass", "CORElearn", "corHMM", "corpcor", "CorReg", "corrgram", "CountsEPPM", "CovSel", "coxinterval", "coxme", "coxphf", "CoxRidge", "CpGassoc", "cplm", "crank", "crawl", "crayon", "crch", "crmn", "Crossover", "crossval", "crp.CSFP", "crqa", "crrstep", "CRTSize", "cshapes", "csn", "csvread", "cts", "cubfits", "curl", "d3Network", "DAAG", "dae", "daewr", "darch", "data.table", "DatABEL", "datacheck", "DataCombine", "dataRetrieval", "dataview", "dawai", "dbmss", "dcemriS4", "dcGOR", "dclone", "DCluster", "dcmle", "ddalpha", "DDD", "decctools", "decompr", "Deducer", "deducorrect", "degreenet", "Delaporte", "deldir", "dendextend", "dendextendRcpp", "dendsort", "denpro", "densityClust", "DEoptimR", "depend.truncation", "depmixS4", "DepthProc", "descomponer", "descr", "DescribeDisplay", "DescTools", "desirability", "deSolve", "detect", "devEMF", "devtools", "DFIT", "dglm", "dgmb", "dhglm", "DiceDesign", "DiceEval", "DiceKriging", "DiceOptim", "diffIRT", "difR", "digest", "diptest", "directlabels", "directPA", "DirichletReg", "Disake", "disclapmix", "DiscreteLaplace", "discreteRV", "DiscreteWeibull", "diseasemapping", "dismo", "Distance", "distillery", "distrDoc", "distrom", "diveMove", "diveRsity", "dkDNA", "DLMtool", "dma", "DNAprofiles", "dnet", "doBy", "docopt", "DoE.base", "doMC", "domino", "doParallel", "DoseFinding", "doSNOW", "dosresmeta", "dostats", "DoubleExpSeq", "downloader", "dpcR", "dplR", "dr", "drc", "drgee", "drmdel", "dsample", "dse", "DSL", "dslice", "dsm", "DSsim", "DTR", "dtw", "dunn.test", "dynamicTreeCut", "dynBiplotGUI", "DynNom", "dynsim", "e1071", "earth", "EasyABC", "EBEN", "EBMAforecast", "Ecdat", "ecespa", "Ecfun", "ecoengine", "ecoreg", "ecoretriever", "ecospat", "ecp", "editrules", "eegkit", "eeptools", "effects", "EffectStars", "effsize", "egcm", "eggCounts", "eha", "eHOF", "EIAdata", "ElemStatLearn", "ELT", "embryogrowth", "EMCluster", "emdbook", "emil", "EMMREML", "emplik", "emplik2", "enaR", "ENMeval", "enpls", "ensembleBMA", "entropart", "enviPat", "enviPick", "EnviroStat", "EnvNicheR", "EnvStats", "Epi", "EpiContactTrace", "EpiModel", "epinet", "epiR", "equateIRT", "equivalence", "erboost", "erer", "ergm", "ergm.count", "ergm.graphlets", "eRm", "ERP", "EstCRM", "ETAS", "etasFLP", "ETLUtils", "EvalEst", "evaluate", "Evapotranspiration", "evd", "eVenn", "eventInterval", "evobiR", "evolvability", "EWGoF", "Exact", "exact2x2", "exactci", "exactRankTests", "exams", "excursions", "expands", "expm", "expsmooth", "ExtDist", "extracat", "ExtremeBounds", "extRemes", "extremevalues", "ez", "FactoClass", "FactoMineR", "FAdist", "Fahrmeir", "fail", "falsy", "fame", "Familias", "fanc", "fanovaGraph", "fanplot", "FAOSTAT", "faoutlier", "far", "faraway", "fast", "fastclime", "fastcluster", "FastHCS", "fastHICA", "FastImputation", "fastR", "FastRCS", "FastRWeb", "FatTailsR", "FAwR", "fCertificates", "fclust", "fcros", "fda.usc", "fdakma", "fdasrvf", "fdatest", "FDboost", "fdrtool", "fdth", "feature", "features", "federalregister", "FeedbackTS", "ffbase", "FFD", "FGSG", "FHtest", "fICA", "fields", "FieldSim", "filehash", "FinCal", "FindIt", "fishmove", "fitdistrplus", "flam", "flexCWM", "FlexParamCurve", "flexsurv", "FLLat", "flora", "fmsb", "fOptions", "forams", "foreach", "ForeCA", "forecast", "foreign", "forestplot", "formatR", "Formula", "formula.tools", "fpc", "fptdApprox", "frailtypack", "Frames2", "frbs", "freqparcoord", "freqweights", "FRESA.CAD", "frm", "fscaret", "fslr", "fSRM", "ftsa", "FunChisq", "FuncMap", "funFEM", "futile.any", "futile.logger", "FuzzyNumbers", "fuzzyRankTests", "FuzzyStatProb", "FWDselect", "fwi.fbp", "G2Sd", "gam", "gamair", "gambin", "gamboostLSS", "gamclass", "games", "gamlr", "gamlss", "gamlss.add", "gamlss.cens", "gamlss.data", "gamlss.demo", "gamlss.dist", "gamlss.mx", "gamlss.spatial", "gamlss.tr", "gamlss.util", "gap", "gapmap", "GB2", "gbm", "GCD", "gcmr", "gdata", "gdistance", "gee", "geeM", "geepack", "geigen", "geiger", "gems", "gemtc", "genalg", "gendata", "gender", "GeneNet", "GeneticTools", "GENLIB", "genoPlotR", "GenOrd", "GenSA", "genSurv", "geoBayes", "GeoLight", "GEOmap", "geometry", "geomorph", "geophys", "geoR", "geoRglm", "geoscale", "geosphere", "geostatsp", "geotopbricks", "geozoo", "GetoptLong", "gets", "GEVcdn", "GEVStableGarch", "GGally", "ggdendro", "GGIR", "ggm", "ggmap", "ggmcmc", "GGMselect", "ggparallel", "ggplot2", "ggtern", "ggthemes", "ggvis", "GIGrvg", "glarma", "glcm", "gld", "GLDEX", "glinternet", "glmmLasso", "glmnet", "glmx", "GlobalOptions", "GLSME", "GMCM", "gMCP", "Gmisc", "gmm", "gmodels", "gMWT", "GNE", "gnm", "gnumeric", "GoFKernel", "goft", "goftest", "googleVis", "GPfit", "gplots", "GPLTR", "gProfileR", "GPvam", "gRain", "gramEvol", "granovaGG", "GrapheR", "graphicsQC", "gRbase", "greport", "gridDebug", "gridExtra", "gridGraphviz", "gridSVG", "groc", "GroupSeq", "grplasso", "grpreg", "GRTo", "gsbDesign", "gsDesign", "GSE", "gSeg", "gsl", "GSM", "gss", "gsscopu", "gtable", "gte", "gtools", "GuardianR", "GUILDS", "gumbel", "GUTS", "gvcm.cat", "GWAF", "gWidgets2", "GWmodel", "GWRM", "hamlet", "HandTill2001", "hapassoc", "HapEstXXR", "Haplin", "haplo.stats", "HardyWeinberg", "hda", "HDclassif", "hdi", "HDPenReg", "heatmap3", "helsinki", "heplots", "hergm", "hexbin", "hglm", "HH", "HHG", "hht", "HiClimR", "hiddenf", "HiddenMarkov", "hierfstat", "highr", "highriskzone", "HiLMM", "HistData", "HistogramTools", "hitandrun", "hive", "HiveR", "HLMdiag", "HLSM", "Hmisc", "HMP", "HMPTrees", "HMR", "Holidays", "homals", "hot.deck", "HotDeckImputation", "hpcwld", "hpoPlot", "HSAUR", "HSAUR2", "HSAUR3", "htmlTable", "htmltools", "hts", "httpuv", "httr", "huge", "hwde", "HWEintrinsic", "HWxtest", "hybridEnsemble", "hybridHclust", "hydrostats", "hypergeo", "hyperSpec", "hypervolume", "hysteresis", "IASD", "iBATCGH", "IBDhaploRtools", "ibelief", "ibr", "iC10", "ica", "icamix", "ICC", "icd9", "icensmis", "ICS", "ICSNP", "ifs", "iGasso", "IgorR", "igraph", "igraphdata", "imguR", "imputeLCMD", "imputeYn", "in2extRemes", "indicspecies", "influence.ME", "influence.SEM", "informR", "INLABMA", "inline", "intergraph", "InterVA4", "intervals", "intsvy", "investr", "ipdw", "ipfp", "ipred", "iqLearn", "irace", "irlba", "isa2", "isingLenzMC", "IsingSampler", "Iso", "ISOcodes", "isotone", "IsotopeR", "ISwR", "iterators", "iterpc", "jaatha", "jackknifeKME", "JADE", "JAGUAR", "JBTools", "JM", "JoSAE", "jsonlite", "jtrans", "kappalab", "kedd", "kelvin", "kequate", "kernelFactory", "kernlab", "KernSmooth", "KFAS", "kimisc", "kin.cohort", "kinfit", "kinship2", "kknn", "klausuR", "kmc", "kml", "kml3d", "knitcitations", "knitr", "knitrBootstrap", "kofnGA", "kohonen", "kolmim", "koRpus", "krm", "ks", "kSamples", "kselection", "kyotil", "labdsv", "label.switching", "labstatR", "LaF", "laGP", "Lahman", "LakeMetabolizer", "lambda.r", "lambda.tools", "LARF", "latdiag", "latentnet", "Laterality", "lattice", "latticeExtra", "LatticeKrig", "lava", "lavaan", "lavaan.survey", "lawstat", "lazyWeave", "lcmm", "lctools", "lda", "leafletR", "lessR", "letsR", "lfe", "lgarch", "lhs", "LiblineaR", "lifecontingencies", "LifeTables", "likelihood", "likeLTD", "LindenmayeR", "lineup", "LinRegInteractive", "LINselect", "lm.br", "lme4", "lmeNB", "lmeNBBayes", "LMERConvenienceFunctions", "lmerTest", "LMest", "lmm", "lmmot", "lmms", "lmom", "lmomco", "Lmoments", "lmomRFA", "lmSupport", "lmtest", "loa", "localgauss", "logcondens", "logcondiscr", "LogicReg", "LogisticDx", "logmult", "logspline", "longitudinal", "longitudinalData", "LoopAnalyst", "lordif", "LPCM", "LPS", "lpSolve", "lpSolveAPI", "LPStimeSeries", "lqmm", "lsa", "LSAfun", "lsgl", "lsmeans", "lsr", "ltmle", "LTPDvar", "ltsa", "ltsk", "lubridate", "lvm4net", "lxb", "mada", "Maeswrap", "magicaxis", "MAINT.Data", "MALDIquant", "MAMS", "manipulate", "Map2NCBI", "mapdata", "MapGAM", "mapmisc", "mapproj", "maps", "mapStats", "maptools", "maptpx", "marelac", "MareyMap", "markdown", "marked", "markovchain", "MarkowitzR", "marmap", "maSAE", "MASS", "MASSTIMATE", "Matching", "MatchingFrontier", "Matrix", "MatrixEQTL", "MatrixModels", "matrixpls", "matrixStats", "maxLik", "maxstat", "mbbefd", "mbest", "mboost", "mc2d", "mclust", "mcmc", "MCMC.OTU", "MCMC.qpcr", "MCMCglmm", "MCMCpack", "mcmcplots", "mcmcse", "MCPAN", "mda", "mdatools", "mded", "mdsdt", "meboot", "mederrRank", "mediation", "mefa", "mefa4", "memisc", "memoise", "memuse", "merror", "meta", "metacom", "metafor", "metaLik", "metap", "metaplus", "metaRNASeq", "metasens", "MetaSKAT", "meteoForecast", "MethComp", "mets", "mfp", "mgcv", "MGLM", "MGSDA", "mht", "mi", "mice", "miceadds", "microbenchmark", "MicroDatosEs", "micromapST", "MicSim", "midasr", "migest", "migui", "MIICD", "mime", "minerva", "miniCRAN", "minpack.lm", "mirt", "mirtCAT", "miscFuncs", "miscset", "missMDA", "MissMech", "mistat", "mistral", "mix", "MixedTS", "mixexp", "mixlm", "MixMAP", "mixOmics", "mixPHM", "MixSim", "mixsmsn", "mixtools", "mixture", "mkin", "MKmisc", "MLDS", "mlr", "mmand", "mmcm", "mmeln", "mmod", "mnlogit", "mnormt", "modehunt", "MODISTools", "mombf", "MonetDB.R", "monitoR", "monmlp", "monomvn", "MonoPoly", "monreg", "Morpho", "morse", "MortalitySmooth", "mosaic", "mosaicData", "mp", "mpath", "MPCI", "mpoly", "MPSEM", "mpt", "MPTinR", "MPV", "mra", "mrds", "MSBVAR", "msda", "MSG", "msgl", "msm", "msr", "msSurv", "MST", "mstate", "MTS", "MTurkR", "multcomp", "multcompView", "multgee", "multic", "multicon", "multicool", "multigroup", "MultiLCIRT", "multilevelPSA", "MultiPhen", "multiPIM", "multipleNCC", "multisensi", "multitaper", "multiwayvcov", "MultNonParam", "MuMIn", "munfold", "munsell", "munsellinterpol", "muRL", "mutoss", "mutossGUI", "MVA", "mvglmmRank", "mvmeta", "mvMORPH", "MVN", "mvnfast", "mvngGrAd", "mvoutlier", "mvProbit", "MVR", "mvSLOUCH", "mvtnorm", "mwa", "MXM", "nabor", "nadiv", "nanop", "NanoStringNorm", "NAPPA", "nat", "nat.templatebrains", "nat.utils", "NbClust", "NBDdirichlet", "nbpMatching", "nCal", "ncdf.tools", "ncdf4", "nCDunnett", "ncf", "NCmisc", "ncvreg", "ndl", "ndtv", "NEff", "negenes", "nephro", "netmeta", "nets", "network", "networkDynamic", "networkDynamicData", "networksis", "neuroim", "Newdistns", "NHANES", "NHPoisson", "Nippon", "nleqslv", "nlme", "nlmrt", "NLP", "NLPutils", "nlstools", "NlsyLinks", "NMF", "NMOF", "nnet", "nodeHarvest", "nonlinearTseries", "nonnest2", "nontarget", "nopp", "nor1mix", "nordklimdata1", "nortest", "nparcomp", "NPBayesImpute", "npbr", "NPCD", "npcp", "nplr", "NPMLEcmprsk", "npmv", "NSM3", "numbers", "numDeriv", "numOSL", "OAIHarvester", "oce", "OceanView", "ocedata", "ODMconverter", "OmicKriging", "ONETr", "OpasnetUtils", "opefimor", "openair", "opencpu", "openNLP", "openNLPdata", "openssl", "openxlsx", "operator.tools", "operators", "OPI", "optiRum", "optmatch", "optparse", "optpart", "orca", "ORCME", "OrdFacReg", "ordinal", "OrdNor", "ordPens", "oro.dicom", "oro.nifti", "orsk", "orthogonalsplinebasis", "ouch", "OutbreakTools", "OUwie", "overlap", "packrat", "packS4", "PAGWAS", "pairwise", "pairwiseCI", "paleotree", "paleoTS", "pamm", "pan", "pander", "papeR", "parallelMap", "ParamHelpers", "parboost", "ParetoPosStable", "parfm", "parma", "partDSA", "partitions", "party", "partykit", "patchDVI", "pavo", "PBD", "PBImisc", "pbivnorm", "pbkrtest", "PBSmapping", "PBSmodelling", "pca3d", "pcalg", "pcIRT", "PCIT", "pcnetmeta", "PCovR", "pdc", "pdfetch", "pdR", "peacots", "pedgene", "pegas", "PEIP", "penalizedLDA", "pendensity", "penDvine", "peptider", "Peptides", "pequod", "perARMA", "PerFit", "performanceEstimation", "PermAlgo", "PerMallows", "permute", "pgmm", "phangorn", "pheatmap", "phenability", "phenex", "pheno2geno", "phenology", "PHeval", "phia", "phonR", "phonTools", "phreeqc", "phyclust", "phylin", "phylobase", "phylolm", "phytools", "pi0", "picasso", "PIGShift", "pipeR", "pitchRx", "PK", "pkgKitten", "PKI", "pks", "planar", "planor", "PlayerRatings", "plfm", "plm", "plot3D", "plotmo", "plotpc", "plotrix", "plotSEMM", "pls", "plsgenomics", "plspm", "plyr", "PMCMR", "pmml", "pmmlTransformations", "pmr", "pocrm", "pollstR", "polspline", "polyapost", "polyclip", "polyCub", "PolyPatEx", "polysat", "pomp", "pooh", "popbio", "PopED", "PopGenome", "poppr", "popsom", "portfolio", "PortRisk", "potts", "PoweR", "Power2Stage", "powerGWASinteraction", "poweRlaw", "powerMediation", "powerSurvEpi", "PowerTOST", "ppcor", "ppmlasso", "pracma", "PracTools", "prefmod", "PReMiuM", "preseqR", "prettyR", "prettyunits", "prevalence", "prim", "primerTree", "PRISMA", "pROC", "prodlim", "profileR", "protr", "proxy", "pryr", "PSAboot", "pscl", "psData", "pse", "psidR", "pspline", "PST", "psych", "psychomix", "psychotools", "psychotree", "PTAk", "PtProcess", "ptw", "PVAClone", "pvclass", "pvclust", "pwr", "pwt8", "pxweb", "QCA", "QCAGUI", "qdap", "qdapDictionaries", "qdapRegex", "qdapTools", "qgraph", "qicharts", "qiimer", "qlcMatrix", "qmethod", "QoLR", "qrnn", "qtl", "qtlbook", "qtlmt", "QTLRel", "qualityTools", "qualV", "Quandl", "QuantifQuantile", "quantmod", "quantreg", "quantregForest", "quantregGrowth", "quantspec", "questionr", "queueing", "qvcalc", "R.cache", "R.devices", "R.huge", "R.matlab", "R.methodsS3", "R.oo", "R.rsp", "R.utils", "R0", "R1magic", "R2admb", "R2BayesX", "R2Cuba", "R2jags", "R2OpenBUGS", "R2SWF", "R2WinBUGS", "R4CouchDB", "r4ss", "R6", "RadOnc", "RAdwords", "rags2ridges", "RAHRS", "rainbow", "ramps", "random", "RandomFields", "randomForest", "randomForestSRC", "randomizeBE", "randomLCA", "randomNames", "randomUniformForest", "randtoolbox", "Rankcluster", "rankhazard", "RANN", "rapport", "Rarity", "rARPACK", "RaschSampler", "raster", "rasterVis", "rattle", "rbamtools", "rbhl", "rbiouml", "rbison", "RCA", "rcbalance", "rcdd", "rcicr", "RCircos", "rCMA", "Rcmdr", "RcmdrMisc", "RcmdrPlugin.EACSPIR", "RcmdrPlugin.EBM", "RcmdrPlugin.EZR", "RcmdrPlugin.FactoMineR", "RcmdrPlugin.HH", "RcmdrPlugin.MPAStats", "RcmdrPlugin.NMBU", "RcmdrPlugin.ROC", "RcmdrPlugin.SCDA", "RcmdrPlugin.survival", "RcmdrPlugin.temis", "RcmdrPlugin.UCA", "Rcolombos", "Rcpp", "RcppArmadillo", "rcppbugs", "RcppDE", "RcppEigen", "RcppExamples", "RcppMLPACK", "RcppParallel", "RcppRedis", "RcppRoll", "RCurl", "Rd2roxygen", "rdd", "Rdistance", "RDML", "Rdpack", "rdrobust", "rdryad", "RDS", "reader", "readMzXmlData", "readODS", "rebird", "rebmix", "recluster", "recommenderlab", "recommenderlabBX", "recommenderlabJester", "recosystem", "REdaS", "redcapAPI", "REDCapR", "refGenome", "RefManageR", "refund", "registry", "reglogit", "regpro", "rehh", "relations", "reldist", "relevent", "ReliabilityTheory", "relimp", "relSim", "relsurv", "rEMM", "remMap", "remote", "Renext", "RenextGUI", "rentrez", "repfdr", "replicationInterval", "repmis", "repolr", "ReporteRs", "reportr", "reporttools", "REPPlab", "resample", "ResourceSelection", "restorepoint", "rex", "Rfacebook", "rFerns", "rfigshare", "rfishbase", "rfisheries", "Rfit", "RForcecom", "rfordummies", "rfPermute", "RGA", "Rgbp", "rgenoud", "rgexf", "rgl", "Rglpk", "RgoogleMaps", "rgr", "RGraphics", "rhosp", "RhpcBLASctl", "RImageJROI", "RImpala", "RInside", "RInSp", "rio", "rioja", "RISmed", "RItools", "riverplot", "rivervis", "RJaCGH", "rjags", "rJava", "RJSDMX", "rjstat", "RKEA", "rknn", "rkt", "Rlabkey", "rLakeAnalyzer", "rlecuyer", "rlist", "RLRsim", "rmaf", "rmarkdown", "RMediation", "rmetasim", "rmgarch", "rminer", "Rmixmod", "rmp", "Rmpfr", "rms", "rneos", "RNetCDF", "RNeXML", "rngWELL", "RNiftyReg", "rNOMADS", "ROAuth", "robCompositions", "RobPer", "RObsDat", "robumeta", "RobustAFT", "robustbase", "robustlmm", "robustloggamma", "robustreg", "rockchalk", "ROCR", "ROCt", "rootSolve", "rorutadis", "RoughSets", "rowr", "roxygen2", "royston", "rpart", "rpart.plot", "rpf", "rpg", "rPlant", "rplexos", "rplos", "RPMG", "RPPanalyzer", "rPref", "rprintf", "RProtoBuf", "RPublica", "RPushbullet", "rPython", "Rquake", "rrBLUP", "rrcov", "rrcovHD", "rrcovNA", "Rrdrand", "rredis", "rriskDistributions", "RRreg", "RSA", "RSclient", "RSDA", "rsdmx", "rseedcalc", "RSEIS", "rsem", "RSGHB", "RSiteCatalyst", "rsm", "RSNNS", "rsnps", "RSNPset", "RSocrata", "Rsolnp", "Rsomoclu", "rspa", "RSpincalc", "rstream", "rstudioapi", "rsunlight", "RTDE", "rTensor", "rtfbs", "RTOMO", "rts", "Rtsne", "rucm", "rugarch", "RUnit", "runjags", "Runuran", "RVAideMemoire", "rvalues", "Rvcg", "rvertnet", "rvest", "RVsharing", "Rwave", "RWeka", "RWekajars", "rworldmap", "RXMCDA", "ryouready", "s20x", "s2dverification", "s4vd", "saccades", "sads", "sae", "SAFD", "SamplerCompare", "sampleSelection", "samplesize", "samplesize4surveys", "sampling", "SamplingStrata", "samplingVarEst", "sandwich", "sanon", "sapa", "SASxport", "SAVE", "sca", "scales", "scam", "scatterplot3d", "SCGLR", "scholar", "schoRsch", "scidb", "SciencesPo", "SCMA", "scout", "scriptests", "SCRT", "scuba", "SCVA", "sda", "sdcMicro", "SDD", "sde", "sdef", "sdmvspecies", "sdprisk", "seacarb", "seasonal", "secr", "seedy", "SEERaBomb", "segmented", "selectiongain", "selectMeta", "SelvarMix", "sem", "semiArtificial", "SEMID", "SemiMarkov", "SemiParBIVProbit", "semTools", "sensitivity", "sensitivitymv", "sensR", "SenSrivastava", "separationplot", "seqDesign", "seqMeta", "seqminer", "Sequential", "sequenza", "seriation", "servr", "sets", "setwidth", "sfsmisc", "SGCS", "sgeostat", "sglasso", "sglOptim", "sgof", "SGP", "SGPdata", "shapes", "SharpeR", "sharx", "shiny", "shinyAce", "shinyBS", "shinyFiles", "shotGroups", "showtext", "ShrinkCovMat", "sig", "signal", "Sim.DiffProc", "SimCorMultRes", "simctest", "simecol", "Simile", "SIMMS", "simMSM", "simone", "simPH", "SimplicialCubature", "SimSeq", "sirad", "sirt", "SIS", "sitar", "SixSigma", "sjPlot", "SKAT", "Skillings.Mack", "skmeans", "Sleuth2", "Sleuth3", "slfm", "SLHD", "smaa", "smacof", "SmarterPoland", "smoother", "smoothHR", "smoothSurv", "smoothtail", "sms", "smss", "sn", "snow", "snowfall", "snowFT", "snpEnrichment", "sns", "SNSequate", "soc.ca", "SocialMediaMineR", "softclassval", "SoftClustering", "softImpute", "soilphysics", "soiltexture", "soilwater", "solaR", "solr", "sorvi", "sotkanet", "sp", "spacom", "spam", "spaMM", "sparkTable", "sparr", "sparseBC", "sparseLDA", "SparseM", "spartan", "spatgraphs", "spatial", "spatialCovariance", "SpatialEpi", "SpatialExtremes", "spatialprobit", "SpatialTools", "SpatialVx", "spatstat", "spatsurv", "spBayes", "spBayesSurv", "spc", "spcadjust", "spcosa", "spd", "spdep", "spdynmod", "SpecsVerification", "spectralGP", "speedglm", "sperich", "spgrass6", "spgwr", "spikeSlabGAM", "splancs", "SPmlficmcm", "spnet", "SPODT", "SPOT", "spTimer", "squash", "ssanv", "SSDforR", "ssize.fdr", "SSN", "ssym", "st", "stabledist", "StAMPP", "stargazer", "StatDA", "StatDataML", "statebins", "StatMatch", "StatMethRank", "statmod", "statnet", "statnet.common", "StatRank", "STEPCAM", "StereoMorph", "stm", "stocc", "stochvol", "stream", "StreamMetabolism", "streamMOA", "stringdist", "stringi", "stringr", "strucchange", "strum", "stylo", "subplex", "subrank", "subselect", "summarytools", "SuperLearner", "SuppDists", "support.BWS", "support.CEs", "Surrogate", "survival", "survMisc", "survPresmooth", "SurvRegCensCov", "survsim", "svd", "svKomodo", "SvyNom", "sweidnumbr", "sybil", "sybilccFBA", "sybilEFBA", "symbolicDA", "synbreed", "synbreedData", "synchronicity", "synthpop", "sysfonts", "systemfit", "tab", "TableMonster", "tableone", "TAM", "TapeR", "TAQMNGR", "taRifx.geo", "taxize", "Taxonstand", "tbart", "TcGSA", "TDA", "TDMR", "TeachingDemos", "TeachingSampling", "teigen", "TEQR", "tergm", "TESS", "testit", "TestScorer", "testthat", "texreg", "textcat", "textir", "TFDEA", "TFMPvalue", "tfplot", "tframe", "tframePlus", "tgp", "TH.data", "ThreeWay", "threg", "ThresholdROC", "Tides", "tidyr", "tigerstats", "tikzDevice", "tileHMM", "timeDate", "timeordered", "timereg", "timeSeries", "timetools", "TimeWarp", "TIMP", "Tinflex", "tis", "tm", "tm.plugin.dc", "tm.plugin.europresse", "tm.plugin.lexisnexis", "tm.plugin.webmining", "tmle.npvi", "tmvtnorm", "tnet", "tolerance", "TopKLists", "TPmsm", "TR8", "track", "TraMineR", "TraMineRextras", "transport", "TreatmentSelection", "treatSens", "tree", "treebase", "treeclim", "treecm", "treelet", "treemap", "TreeSim", "triangle", "TriMatch", "trip", "tripack", "TripleR", "trust", "TScompare", "TSdbi", "TSdist", "tsDyn", "tseries", "tsfa", "TSfame", "tsintermittent", "TSP", "tspmeta", "TSsql", "TSSQLite", "TTAinterfaceTrendAnalysis", "TTR", "TUWmodel", "tvm", "twang", "twitteR", "twostageTE", "TwoStepCLogit", "udunits2", "ump", "unbalanced", "unittest", "unmarked", "urca", "usdm", "useful", "userfriendlyscience", "UsingR", "usl", "uuid", "varComp", "vardiag", "vardpoor", "vcd", "vcdExtra", "vcrpart", "vegan", "vegan3d", "vegdata", "VennDiagram", "verification", "VGAM", "VGAMdata", "VideoComparison", "VIM", "VineCopula", "virtualspecies", "visreg", "visualFields", "VisuClust", "VLMC", "VNM", "vows", "VPdtw", "VSURF", "W2CWM2C", "WARN", "Wats", "wbs", "wccsom", "weightedScores", "weights", "weirs", "wesanderson", "wgaim", "WhopGenome", "WikipediR", "wle", "wordnet", "wppExplorer", "wq", "WriteXLS", "WRS2", "wskm", "wsrf", "wtcrsk", "x.ent", "XBRL", "xergm", "xgboost", "XiMpLe", "xkcd", "XLConnect", "XML", "XNomial", "xoi", "xtable", "xtermStyle", "yaImpute", "yhatr", "YPmodel", "YuGene", "yuima", "Zelig", "ZeligChoice", "zic", "zoeppritz", "zoib", "zoo"))
library(swirl)
)
))
)
